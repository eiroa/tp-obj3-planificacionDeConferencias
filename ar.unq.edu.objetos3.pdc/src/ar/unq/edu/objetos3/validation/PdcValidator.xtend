/*
 * generated by Xtext
 */
package ar.unq.edu.objetos3.validation

import org.eclipse.xtext.validation.Check
import ar.unq.edu.objetos3.pdc.*
import java.util.HashMap
import java.util.List
import java.util.ArrayList
import java.lang.reflect.Array
import org.eclipse.xtend.typesystem.Type

//import org.eclipse.xtext.validation.Check
/**
 * Custom validation rules. 
 *
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
class PdcValidator extends AbstractPdcValidator {

	public static val INVALID_NAME = 'invalidName'

	def sortByHorario(Iterable<Actividad> list) {
		return list.sortBy[horario.minutos].sortBy[horario.hora]
	}

	def minutosTotalesConDuracion(Actividad a) {
		return a.horario.hora * 60 + a.horario.minutos + a.duracion
	}

	def minutosTotalesSinDuracion(Actividad a) {
		a.horario.hora * 60 + a.horario.minutos
	}

	def seSolapanHorarios(Actividad a1, Actividad a2) {
		return a1.minutosTotalesConDuracion() > a2.minutosTotalesSinDuracion()
	}

	def validarActividadesSolapadas(
		Iterable<Actividad> list,
		(Actividad)=>Boolean additionalValidation,
		String text1,
		String text2,
		String text3
	) {
		var elementoActual = 0
		for (a : list) {
			if (list.size - elementoActual > 1) {
				var next = list.get(elementoActual + 1)
				if (additionalValidation.apply(a) && seSolapanHorarios(a, next)) {
					error(text1 + a.titulo + text2 + next.titulo + text3, a.eContainer(), a.eContainingFeature(), -1)
				}
				elementoActual++
			}
		}
	}

	@Check
	def checkActividadEmpiezaConMayuscula(Actividad actividad) {
		if (!Character.isUpperCase(actividad.titulo.charAt(0))) {
			warning(
				'El titulo deberia comenzar con mayuscula',
				PdcPackage.Literals.ACTIVIDAD__TITULO,
				INVALID_NAME
			)
		}
	}

	@Check
	def void checkTituloEsUnico(Schedule s) {
		if (s.actividades.map[a|a.titulo].toList.length > s.actividades.map[a|a.titulo].toSet.length) {
			error('Existen titulos repetidos', PdcPackage.Literals.SCHEDULE__NOMBRE, INVALID_NAME)
		}
	}

	@Check
	def checkCharlaDuracion(Actividad actividad) {

		if (actividad.tipo.eClass.name.equals("Charla") && actividad.duracion < 30) {
			error('Una charla no puede durar menos de 30 minutos', PdcPackage.Literals.ACTIVIDAD__DURACION,
				INVALID_NAME)
		}
	}

	@Check
	def checkMesaDebateDuracion(Actividad actividad) {
		if (actividad.tipo.eClass.name.equals("Mesa de debate") && actividad.duracion < 60) {
			error('Una mesa de debate no puede durar menos de 1 hora', PdcPackage.Literals.ACTIVIDAD__DURACION,
				INVALID_NAME)
		}
	}

	@Check
	def checkOradoresDeDistintaOrganizacion(Actividad actividad) {
		if (actividad.tipo.eClass.name.equals("Mesa de debate") && actividad.oradores.map[organizacion].toSet.size < 2) {
			error('Una mesa de debate no puede estar asociada a una sola organizacion',
				PdcPackage.Literals.ACTIVIDAD__ESPACIO, INVALID_NAME)
		}
	}

	@Check
	def checkExistenciaDeTitulos(Actividad actividad) {
		if (actividad.titulo.nullOrEmpty) {
			error('Actividad requiere titulo', PdcPackage.Literals.ACTIVIDAD__DURACION, INVALID_NAME)
		}
	}

	@Check
	def checkActividadesConcurrentes(PDC pdc) {

		//		Genero un mapa con actividades y espacio, si resulta que un espacio tiene dos actividades, 
		//		verificar concurrencias 
		pdc.schedule.actividades.groupBy[a|a.espacio].forEach [ p1, p2 | //key,value
			if (p2.length > 1) {

				//En este punto ya tenemos las actividades de un mismo espacio ordenadas segun el horario
				//Ahora debemos corroborar que no se superpongan
				validarActividadesSolapadas(p2.sortByHorario(), [a|true], "Las actividades ", " y ",
					" se superponen en el mismo lugar")
			}
		]
	}

	@Check
	def checkBloquesValidos(PDC pdc) {
		pdc.schedule.actividades.groupBy[a|a.espacio].forEach [ p1, p2 | //key,value
			// Premisa: Un bloque representa actividades encerradas entre 2 breaks, por lo tanto, espacios
			// con menos de 3 actividades no califican
			if (p2.length > 3) {
				var sortedValues = p2.sortByHorario()

				var primerBreakEncontrado = false

				var duracionTotal = 0
				var List tracks = new ArrayList
				val List organizaciones = new ArrayList

				for (a : sortedValues) {
					if (primerBreakEncontrado && !a.tipo.eClass.name.equals("Break")) {

						//Encontramos una actividad del bloque
						duracionTotal = duracionTotal + a.duracion

						//Agregamos el track
						tracks.add(a.track)

						//Agregamos organizaciones involucradas
						a.oradores.forEach [ o |
							organizaciones.add(o.organizacion)
						]
					}
					if (primerBreakEncontrado && a.tipo.eClass.name.equals("Break")) {

						//Encontramos el segundo break, verificar si es bloque
						if (tracks.size > 1) {

							//Hay al menos 2 actividades, se ha encontrado un bloque
							if (duracionTotal > 120) {

								//El bloque dura más de 2 horas
								error(
									"Existe un bloque de actividades en el lugar " + p1.name +
										" con una duracion mayor de 2 horas", PdcPackage.Literals.PDC__SCHEDULE,
									INVALID_NAME)
							}
							if (tracks.toSet.size > 1) {

								//El bloque posee tracks distintos
								error(
									"Existe un bloque de actividades en el lugar " + p1.name +
										" cuyos tracks no corresponden al mismo", PdcPackage.Literals.PDC__SCHEDULE,
									INVALID_NAME)
							}
							if (organizaciones.toSet.size == 1) {

								//El bloque esta compuesto por una sola organizacion
								warning(
									"Existe un bloque de actividades en el lugar " + p1.name +
										" perteneciente a una unica organizacion",
									PdcPackage.Literals.PDC__LOS_ESPACIOS, INVALID_NAME)
							}

							//Bloque encontrado y validado, reiniciar valores y continuar checkeo
							duracionTotal = 0
							tracks = new ArrayList
							organizaciones.clear
						} else {

							//Solo 1 actividad entre dos Breaks, no califica como bloque y el break se toma
							//como posible inicio de otro bloque
							duracionTotal = 0
							tracks = new ArrayList
							organizaciones.clear
						}
					}

					if (!primerBreakEncontrado) {
						if (a.tipo.eClass.name.equals("Break")) {

							//Encontramos el primer Break, posible bloque
							println("primer break encontrado...")
							primerBreakEncontrado = true
						}
					}

				/////////////////
				}
			}
		]
	}

	@Check
	def checkConcurrenciaDeOradores(PDC pdc) {
		val map = new HashMap()

		//		Genero un mapa con actividades y oradores
		pdc.losOradores.head.oradores.forEach [ o |
			var actividadesRelacionadas = pdc.schedule.actividades.filter[act|act.oradores.contains(o)]
			map.put(o, actividadesRelacionadas)
		]
		map.forEach [ p1, p2 |
			if (p2.length > 1) {
				var sortedValues = p2.sortByHorario()

				//En este punto ya tenemos las actividades de un mismo espacio ordenadas segun el horario
				//Ahora debemos corroborar que no se superpongan
				var x = 0
				for (a : sortedValues) {
					if (sortedValues.size - x > 1) {
						var next = sortedValues.get(x + 1)
						if (a.minutosTotalesConDuracion() == next.minutosTotalesSinDuracion()) {
							warning(
								"Advertencia, el orador " + p1.name + " esta asignado a las actividades adyacentes" +
									a.titulo + " y " + next.titulo, p1.eContainer(), p1.eContainingFeature(), -1)
						} else {
							if (seSolapanHorarios(a, next)) {
								error(
									"Las actividades " + a.titulo + " y " + next.titulo + " del orador " + p1.name +
										" se superponen", p1.eContainer(), p1.eContainingFeature(), -1)
							}
						}
						x++
					}
				}
			}
		]
	}

	@Check
	def checkExclusividadCharlasKeynote(PDC pdc) {
		validarActividadesSolapadas(
			pdc.schedule.actividades.filter[act|act.tipo.eClass.name.equals("Charla")].sortByHorario(),
			[a|a.keynote],
			"La charla keynote ",
			" se superpone con el horario de la actividad ",
			""
		)
	}

	@Check
	def checkMesaDebate2Oradores(Actividad actividad) {
		if (actividad.tipo.eClass.name.equals("Mesa de debate") && actividad.oradores.length < 2) {
			error('Mesa de debate necesita 2 oradores al menos', PdcPackage.Literals.ACTIVIDAD__ORADORES, INVALID_NAME)
		}
	}

	@Check
	def checkHorariosValidos(Horario horario) {
		if (horario.hora < 0 || horario.hora > 23) {
			error('Hora invalida utilice valores entre 0 y 23', PdcPackage.Literals.HORARIO__HORA, INVALID_NAME)
		}
		if (horario.minutos < 0 || horario.minutos > 59) {
			error('Minutos invalidos utilice valores entre 0 y 59', PdcPackage.Literals.HORARIO__MINUTOS, INVALID_NAME)
		}
	}

	@Check
	def checkDuracionBreak(Actividad actividad) {
		if (actividad.tipo.eClass.name.equals("Break") && actividad.duracion < 15) {
			error('Los breaks no pueden durar menos de 15 minutos', PdcPackage.Literals.ACTIVIDAD__DURACION,
				INVALID_NAME)
		}
	}

	@Check
	def checkDuracionAlmuerzo(Actividad actividad) {
		if (actividad.tipo.eClass.name.equals("Break") && actividad.tipoDeBreak.eClass.name.equals("Almuerzo") && actividad.duracion < 45) {
			error('Los almuerzos no pueden durar menos de 45 minutos', PdcPackage.Literals.ACTIVIDAD__DURACION,
				INVALID_NAME)
		}
	}

	@Check
	def checkAulasConMaquinasSoloParaTalleres(Actividad actividad) {
		if (actividad.espacio.tieneComputadoras && !actividad.tipo.eClass.name.equals("Taller")) {
			error('Un aula con computadoras solo puede utilizarse para talleres', PdcPackage.Literals.ACTIVIDAD__ESPACIO,
				INVALID_NAME)
		}
	}

	@Check
	def checkTallerDebeTenerComputadoras(Actividad actividad) {
		if (actividad.tipo.eClass.name.equals("Taller")&& !actividad.espacio.tieneComputadoras) {
			error('Un taller solo puede llevarse a cabo en un aula con maquinas', PdcPackage.Literals.ACTIVIDAD__ESPACIO,
				INVALID_NAME)
		}
	}

	@Check
	def checkCapacidadActividad(Actividad actividad) {
		val x = actividad.genteEsperada
		switch (x) {
			case null:
				error('Especifique la gente esperada para la actividad ' + actividad.titulo,
					PdcPackage.Literals.ACTIVIDAD__GENTE_ESPERADA, INVALID_NAME)
			case x > actividad.espacio.capacidad:
				error('No hay suficiente espacio en actividad ' + actividad.titulo,
					PdcPackage.Literals.ACTIVIDAD__GENTE_ESPERADA, INVALID_NAME)
			case x < (actividad.espacio.capacidad / 2):
				warning('Existe demasiado espacio en actividad ' + actividad.titulo + ' sin usar',
					PdcPackage.Literals.ACTIVIDAD__GENTE_ESPERADA, INVALID_NAME)
			case x > ( (90 * actividad.espacio.capacidad) / 100):
				warning(
					'La cantidad de gente esperada para la actividad ' + actividad.titulo +
						' es próxima a la capacidad máxima del lugar', PdcPackage.Literals.ACTIVIDAD__GENTE_ESPERADA,
					INVALID_NAME)
		}

	}

}
