/*
 * generated by Xtext
 */
package ar.unq.edu.objetos3.validation

import org.eclipse.xtext.validation.Check
import java.util.HashMap
import java.util.List
import java.util.ArrayList
import extensions.ActivitiesExtension
import ar.unq.edu.objetos3.pdc.*
import extensions.HourExtension
import extensions.Cursor

//import org.eclipse.xtext.validation.Check
/**
 * Custom validation rules. 
 *
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
class PdcValidator extends AbstractPdcValidator {

	public static val INVALID_NAME = 'invalidName'
	public static val INVALID_HOUR = 'invalidHour'
	
	extension ActivitiesExtension = new ActivitiesExtension
	extension HourExtension = new HourExtension
	
	@Check
	def checkActividadEmpiezaConMayuscula(Actividad actividad) {
		if (!Character.isUpperCase(actividad.titulo.charAt(0))) {
			warning(
				'El titulo deberia comenzar con mayuscula',
				PdcPackage.Literals.ACTIVIDAD__TITULO,
				INVALID_NAME
			)
		}
	}

	@Check
	def void checkTituloEsUnico(Schedule s) {
		if (s.actividades.map[a|a.titulo].toList.length > s.actividades.map[a|a.titulo].toSet.length) {
			error('Existen titulos repetidos', PdcPackage.Literals.SCHEDULE__NOMBRE, INVALID_NAME)
		}
	}

	@Check
	def checkCharlaDuracion(Actividad actividad) {

		if (actividad.esCharla && actividad.duracion < 30) {
			error('Una charla no puede durar menos de 30 minutos', PdcPackage.Literals.ACTIVIDAD__DURACION,
				INVALID_NAME)
		}
	}

	@Check
	def checkMesaDebateDuracion(Actividad actividad) {
		if (actividad.esMesaDeDebate && actividad.duracion < 60) {
			error('Una mesa de debate no puede durar menos de 1 hora', PdcPackage.Literals.ACTIVIDAD__DURACION,
				INVALID_NAME)
		}
	}

	@Check
	def checkExistenciaDeTitulos(Actividad actividad) {
		if (actividad.titulo.nullOrEmpty) {
			error('Actividad requiere titulo', PdcPackage.Literals.ACTIVIDAD__DURACION, INVALID_NAME)
		}
	}

	@Check
	def checkActividadesConcurrentes(PDC pdc) {
		pdc.schedule.activitiesSortedByPlaceAndTime.forEach[e,acts |
			var cursor = new Cursor(acts)
			while(cursor.hasNext){
				var act = cursor.current as Actividad
				var nextAct = cursor.next as Actividad
				if (nextAct.inTheMiddleOf(act)) {
					error("Las actividades " + act.titulo + " y " + nextAct.titulo + " se superponen en el mismo espacio",
							PdcPackage.Literals.PDC__LOS_ESPACIOS, INVALID_NAME)
				}	
			}
		]	
	}
		
	
	@Check
	def checkBloquesValidos(PDC pdc){
				pdc.schedule.actividades.groupBy[a|a.espacio].forEach [ p1, p2 | //key,value
				
				
				// Premisa: Un bloque representa actividades encerradas entre 2 breaks, por lo tanto, espacios
				// con menos de 3 actividades no califican
			if (p2.length > 3) {
				println("Actividades posibles de constituir bloque para espacio " +p1+ " ---> " +p2)
				var sortedValues = p2.sortBy[horario.minutos]
				sortedValues = sortedValues.sortBy[horario.hora]

				var primerBreakEncontrado = false
				
				var duracionTotal = 0
				var List tracks = new ArrayList
				val List organizaciones = new ArrayList
				
				for (a : sortedValues) {
					if(primerBreakEncontrado && !a.esBreak){
						//Encontramos una actividad del bloque
						println("posible actividad de bloque...")
						duracionTotal =  duracionTotal + a.duracion
						//Agregamos el track
						println("Duracion hasta el momento: "+duracionTotal)
						tracks.add(a.track)
						println("tracks al momento: "+tracks)
						//Agregamos organizaciones involucradas
						a.oradores.forEach[o | 
							organizaciones.add(o.organizacion)
						]
						println("organizaciones de momento... " + organizaciones)
					}
					if(primerBreakEncontrado && a.esBreak){
						//Encontramos el segundo break, verificar si es bloque
						println("Encontrado el segundo Break")
						if(tracks.size >1){
							//Hay al menos 2 actividades, se ha encontrado un bloque
							if(duracionTotal > 120){
								//El bloque dura más de 2 horas
								error(
								"Existe un bloque de actividades en el lugar " +p1.name + " con una duracion mayor de 2 horas",
								PdcPackage.Literals.PDC__SCHEDULE, INVALID_NAME)
							}
							if(tracks.toSet.size > 1){
								//El bloque posee tracks distintos
								error(
								"Existe un bloque de actividades en el lugar " +p1.name + " cuyos tracks no corresponden al mismo",
								PdcPackage.Literals.PDC__SCHEDULE, INVALID_NAME)
							}
							if(organizaciones.toSet.size == 1){
								//El bloque esta compuesto por una sola organizacion
								warning(
								"Existe un bloque de actividades en el lugar " +p1.name + " perteneciente a una unica organizacion",
								PdcPackage.Literals.PDC__LOS_ESPACIOS, INVALID_NAME)
							}
							//Bloque encontrado y validado, reiniciar valores y continuar checkeo
							duracionTotal= 0
							tracks = new ArrayList
							organizaciones.clear
						}else{
							//Solo 1 actividad entre dos Breaks, no califica como bloque y el break se toma
							//como posible inicio de otro bloque
							duracionTotal= 0
							tracks = new ArrayList
							organizaciones.clear
						}
					}

					if(!primerBreakEncontrado ){
						if(a.esBreak){
							//Encontramos el primer Break, posible bloque
							println("primer break encontrado...")
							primerBreakEncontrado = true
						}
					}
					/////////////////
				}
			}
		]
	}

	@Check
	def checkConcurrenciaDeOradores(PDC pdc) {
		val map = pdc.schedule.activitiesSortedBySpeakerAndTime

		map.forEach [ orador, acts |
		var actividades = acts.toList
		var cursor = new Cursor(actividades)
			while(cursor.hasNext){
				var act = cursor.current as Actividad
				var nextAct = cursor.next as Actividad
				print(act.endTime.equal(nextAct.horario))
				if (act.endTime.equal(nextAct.horario)) {
							warning(
								"Advertencia, el orador " + orador.name + " esta asignado a las actividades adyacentes" +
									act.titulo + " y " + nextAct.titulo, PdcPackage.Literals.PDC__LOS_ORADORES,
								INVALID_NAME)
				} else {
						if (nextAct.inTheMiddleOf(act)) {
							error(
								"Las actividades " + act.titulo + " y " + nextAct.titulo + " del orador " + orador.name +
								" se superponen", PdcPackage.Literals.PDC__SCHEDULE, INVALID_NAME)
							}
						}
			}
		]
	}
	
	@Check
	def checkExclusividadCharlasKeynote(PDC pdc){
		var sortedValues =pdc.schedule.actividades.filter[act | act.esCharla].sortBy[horario.minutos]
		sortedValues = sortedValues.sortBy[horario.hora]
		var x = 0
				for (a : sortedValues) {
					var totalMinutes = a.horario.hora * 60 + a.horario.minutos + a.duracion
					if (sortedValues.size - x > 1) {
						var next = sortedValues.get(x + 1)
						var nextTotalMinutes = next.horario.hora * 60 + next.horario.minutos
						if ( a.keynote && totalMinutes > nextTotalMinutes) {
							error(
								"La charla keynote " + a.titulo +" se superpone con el horario de la actividad " + next.titulo,
								PdcPackage.Literals.PDC__SCHEDULE, INVALID_NAME)
						}
						x++
					}
				}
	}

	@Check
	def checkMesaDebate2Oradores(Actividad actividad) {
		if (actividad.esMesaDeDebate && actividad.oradores.length < 2) {
			error('Mesa de debate necesita 2 oradores al menos', PdcPackage.Literals.ACTIVIDAD__ORADORES, INVALID_NAME)
		}
	}

	@Check
	def checkHorariosValidos(Horario horario) {
		if (horario.hora < 0 || horario.hora > 23) {
			error('Hora invalida utilice valores entre 0 y 23', PdcPackage.Literals.HORARIO__HORA, INVALID_NAME)
		}
		if (horario.minutos < 0 || horario.minutos > 59) {
			error('Minutos invalidos utilice valores entre 0 y 59', PdcPackage.Literals.HORARIO__MINUTOS, INVALID_NAME)
		}
	}


	@Check
	def checkDuracionBreak(Actividad actividad) {
		if (actividad.esBreak && actividad.duracion < 15) {
			error('Los breaks no pueden durar menos de 15 minutos', PdcPackage.Literals.ACTIVIDAD__DURACION,
				INVALID_NAME)
		}
	}

	@Check
	def checkDuracionAlmuerzo(Actividad actividad) {
		if (actividad.esBreak && actividad.tipoDeBreak.eClass.name.equals("Almuerzo") && actividad.duracion < 45) {
			error('Los almuerzos no pueden durar menos de 45 minutos', PdcPackage.Literals.ACTIVIDAD__DURACION,
				INVALID_NAME)
		}
	}

	@Check
	def checkAulasConMaquinasSoloParaTalleres(Actividad actividad) {
		if (actividad.espacio.tieneComputadoras && !actividad.esTaller) {
			error('Un aula con computadoras solo puede utilizarse para talleres', PdcPackage.Literals.ACTIVIDAD__ESPACIO,
				INVALID_NAME)
		}
	}

	@Check
	def checkCapacidadActividad(Actividad actividad) {
		val x = actividad.genteEsperada
		switch (x) {
			case null:
				error('Especifique la gente esperada para la actividad ' + actividad.titulo, PdcPackage.Literals.ACTIVIDAD__GENTE_ESPERADA, INVALID_NAME)
			case x > actividad.espacio.capacidad:
				error('No hay suficiente espacio en actividad ' + actividad.titulo, PdcPackage.Literals.ACTIVIDAD__GENTE_ESPERADA, INVALID_NAME)
			case x < (actividad.espacio.capacidad / 2):
				warning('Existe demasiado espacio en actividad ' +actividad.titulo+ ' sin usar', PdcPackage.Literals.ACTIVIDAD__GENTE_ESPERADA,
					INVALID_NAME)
			case x > ( (90 * actividad.espacio.capacidad) / 100):
				warning('La cantidad de gente esperada para la actividad ' + actividad.titulo+ ' es próxima a la capacidad máxima del lugar',
					PdcPackage.Literals.ACTIVIDAD__GENTE_ESPERADA, INVALID_NAME)
		}

	}
}
