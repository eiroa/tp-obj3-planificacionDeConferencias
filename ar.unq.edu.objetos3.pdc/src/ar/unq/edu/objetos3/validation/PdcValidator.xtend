/*
 * generated by Xtext
 */
package ar.unq.edu.objetos3.validation

import org.eclipse.xtext.validation.Check
import ar.unq.edu.objetos3.pdc.*
import java.util.HashMap
import java.util.List
import java.util.ArrayList
import java.lang.reflect.Array
import org.eclipse.xtend.typesystem.Type

//import org.eclipse.xtext.validation.Check
/**
 * Custom validation rules. 
 *
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
class PdcValidator extends AbstractPdcValidator {

	public static val INVALID_NAME = 'invalidName'

	def sortByHorario(Iterable<Actividad> list) {
		return list.sortBy[horario.minutos].sortBy[horario.hora]
	}

	def minutosTotalesConDuracion(Actividad a) {
		return a.horario.hora * 60 + a.horario.minutos + a.duracion
	}

	def minutosTotalesSinDuracion(Actividad a) {
		a.horario.hora * 60 + a.horario.minutos
	}

	def seSolapanHorarios(Actividad a1, Actividad a2) {
		return a1.minutosTotalesConDuracion() > a2.minutosTotalesSinDuracion()
	}

	def validarActividadesSolapadas(
		Iterable<Actividad> list,
		(Actividad)=>Boolean additionalValidation,
		String text1,
		String text2,
		String text3
	) {
		var elementoActual = 0
		for (a : list) {
			if (list.size - elementoActual > 1) {
				var next = list.get(elementoActual + 1)
				if (additionalValidation.apply(a) && seSolapanHorarios(a, next)) {
					error(text1 + a.titulo + text2 + next.titulo + text3, a, null)
				}
				elementoActual++
			}
		}
	}

	@Check
	def checkActividadEmpiezaConMayuscula(Actividad actividad) {
		if (!Character.isUpperCase(actividad.titulo.charAt(0))) {
			warning(
				'El titulo deberia comenzar con mayuscula',
				PdcPackage.Literals.ACTIVIDAD__TITULO,
				INVALID_NAME
			)
		}
	}

	@Check
	def void checkTituloEsUnico(Schedule s) {
		if (s.actividades.map[a|a.titulo].toList.length > s.actividades.map[a|a.titulo].toSet.length) {
			error('Existen titulos repetidos', PdcPackage.Literals.SCHEDULE__NOMBRE, INVALID_NAME)
		}
	}

	@Check
	def checkCharlaDuracion(Actividad actividad) {

		if (actividad.tipo.eClass.name.equals("Charla") && actividad.duracion < 30) {
			error('Una charla no puede durar menos de 30 minutos', PdcPackage.Literals.ACTIVIDAD__DURACION,
				INVALID_NAME)
		}
	}

	@Check
	def checkMesaDebateDuracion(Actividad actividad) {
		if (actividad.tipo.eClass.name.equals("Mesa de debate") && actividad.duracion < 60) {
			error('Una mesa de debate no puede durar menos de 1 hora', PdcPackage.Literals.ACTIVIDAD__DURACION,
				INVALID_NAME)
		}
	}

	@Check
	def checkOradoresDeDistintaOrganizacion(Actividad actividad) {
		if (actividad.tipo.eClass.name.equals("Mesa de debate") && actividad.oradores.map[organizacion].toSet.size < 2) {
			error('Los oradores participantes de una mesa de debate no pueden participar en la misma organización',
				PdcPackage.Literals.ACTIVIDAD__ESPACIO, INVALID_NAME)
		}
	}

	@Check
	def checkExistenciaDeTitulos(Actividad actividad) {
		if (actividad.titulo.nullOrEmpty) {
			error('Actividad requiere titulo', PdcPackage.Literals.ACTIVIDAD__DURACION, INVALID_NAME)
		}
	}

	@Check
	def checkActividadesConcurrentes(PDC pdc) {
		pdc.schedule.actividades.groupBy[a|a.espacio].forEach [ p1, p2 | //key,value
			if (p2.length > 1) {
				validarActividadesSolapadas(p2.sortByHorario(), [a|true], "Las actividades ", " y ",
					" se superponen en el mismo lugar")
			}
		]
	}
	
	def duracionBloque(Bloque b){
		return b.actividades.fold(0)[resultado, actividad | actividad.duracion + resultado]
	}

	@Check
	def checkBloquesValidos(Bloque bloque) {
		if(bloque.duracionBloque() >120)
			error('Los bloques no pueden durar más de 2 horas', bloque, null)
	}

	@Check
	def checkConcurrenciaDeOradores(PDC pdc) {
		val map = new HashMap()

		//		Genero un mapa con actividades y oradores
		pdc.losOradores.head.oradores.forEach [ o |
			var actividadesRelacionadas = pdc.schedule.actividades.filter[act|act.oradores.contains(o)]
			map.put(o, actividadesRelacionadas)
		]
		map.forEach [ p1, p2 |
			if (p2.length > 1) {
				var sortedValues = p2.sortByHorario()

				//En este punto ya tenemos las actividades de un mismo espacio ordenadas segun el horario
				//Ahora debemos corroborar que no se superpongan
				var x = 0
				for (a : sortedValues) {
					if (sortedValues.size - x > 1) {
						var next = sortedValues.get(x + 1)
						if (a.minutosTotalesConDuracion() == next.minutosTotalesSinDuracion()) {
							warning(
								"Advertencia, el orador " + p1.name + " esta asignado a las actividades adyacentes" +
									a.titulo + " y " + next.titulo, a.eContainer(), a.eContainingFeature(), sortedValues.indexOf(a))
						} else {
							if (seSolapanHorarios(a, next)) {
//								error(
//									"Las actividades " + a.titulo + " y " + next.titulo + " del orador " + p1.name +
//										" se superponen", a.eContainer(), a.eContainingFeature(), sortedValues.indexOf(a))
								error(
									"Las actividades " + a.titulo + " y " + next.titulo + " del orador " + p1.name +
										" se superponen", a, null)
							}
						}
						x++
					}
				}
			}
		]
	}

	@Check
	def checkExclusividadCharlasKeynote(PDC pdc) {
		validarActividadesSolapadas(
			pdc.schedule.actividades.filter[act|act.tipo.eClass.name.equals("Charla")].sortByHorario(),
			[a|a.keynote],
			"La charla keynote ",
			" se superpone con el horario de la actividad ",
			""
		)
	}

	@Check
	def checkMesaDebate2Oradores(Actividad actividad) {
		if (actividad.tipo.eClass.name.equals("Mesa de debate") && actividad.oradores.length < 2) {
			error('Mesa de debate necesita 2 oradores al menos', PdcPackage.Literals.ACTIVIDAD__ORADORES, INVALID_NAME)
		}
	}

	@Check
	def checkHorariosValidos(Horario horario) {
		if (horario.hora < 0 || horario.hora > 23) {
			error('Hora invalida utilice valores entre 0 y 23', PdcPackage.Literals.HORARIO__HORA, INVALID_NAME)
		}
		if (horario.minutos < 0 || horario.minutos > 59) {
			error('Minutos invalidos utilice valores entre 0 y 59', PdcPackage.Literals.HORARIO__MINUTOS, INVALID_NAME)
		}
	}

	@Check
	def checkDuracionBreak(Actividad actividad) {
		if (actividad.tipo.eClass.name.equals("Break") && actividad.duracion < 15) {
			error('Los breaks no pueden durar menos de 15 minutos', PdcPackage.Literals.ACTIVIDAD__DURACION,
				INVALID_NAME)
		}
	}

	@Check
	def checkDuracionAlmuerzo(Actividad actividad) {
		if (actividad.tipo.eClass.name.equals("Break") && actividad.tipoDeBreak.eClass.name.equals("Almuerzo") &&
			actividad.duracion < 45) {
			error('Los almuerzos no pueden durar menos de 45 minutos', PdcPackage.Literals.ACTIVIDAD__DURACION,
				INVALID_NAME)
		}
	}

	@Check
	def checkAulasConMaquinasSoloParaTalleres(Actividad actividad) {
		if (actividad.espacio.tieneComputadoras && !actividad.tipo.eClass.name.equals("Taller")) {
			error('Un aula con computadoras solo puede utilizarse para talleres', PdcPackage.Literals.ACTIVIDAD__ESPACIO,
				INVALID_NAME)
		}
	}

	@Check
	def checkTallerDebeTenerComputadoras(Actividad actividad) {
		if (actividad.tipo.eClass.name.equals("Taller") && !actividad.espacio.tieneComputadoras) {
			error('Un taller solo puede llevarse a cabo en un aula con maquinas', PdcPackage.Literals.ACTIVIDAD__ESPACIO,
				INVALID_NAME)
		}
	}

	@Check
	def actividadesRegistracionYEventoIniciales(PDC pdc) {
		var sorted = pdc.schedule.actividades.sortByHorario()
		if (!sorted.head.tipo.eClass.name.equals("Registracion")) {
			error(
				"La primer actividad debe ser la registración ", sorted.head.eContainer(), sorted.head.eContainingFeature(), -1)
		}
	}

	@Check
	def checkCapacidadActividad(Actividad actividad) {
		val x = actividad.genteEsperada
		switch (x) {
			case null:
				error('Especifique la gente esperada para la actividad ' + actividad.titulo,
					PdcPackage.Literals.ACTIVIDAD__GENTE_ESPERADA, INVALID_NAME)
			case x > actividad.espacio.capacidad:
				error('No hay suficiente espacio en actividad ' + actividad.titulo,
					PdcPackage.Literals.ACTIVIDAD__GENTE_ESPERADA, INVALID_NAME)
			case x < (actividad.espacio.capacidad / 2):
				warning('Existe demasiado espacio en actividad ' + actividad.titulo + ' sin usar',
					PdcPackage.Literals.ACTIVIDAD__GENTE_ESPERADA, INVALID_NAME)
			case x > ( (90 * actividad.espacio.capacidad) / 100):
				warning(
					'La cantidad de gente esperada para la actividad ' + actividad.titulo +
						' es próxima a la capacidad máxima del lugar', PdcPackage.Literals.ACTIVIDAD__GENTE_ESPERADA,
					INVALID_NAME)
		}

	}

}
